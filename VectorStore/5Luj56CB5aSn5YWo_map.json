{
  "0": {
    "text": "## CHECKLISTS: Debugging Reminders\r\n\r\n### 核对表: 关于调试的建议\r\n\r\n#### 寻找缺陷的方法\r\n\r\n- [ ] 使用所有可用数据来构造你的假设。\r\n- [ ] 不断提炼产生错误的测试用例。\r\n- [ ] 在自己的单元测试族中测试代码。\r\n- [ ] 借助可以获得的任何工具。\r\n- [ ] 用不同的方式重现错误。\r\n- [ ] 通过产生更多的数据来构造更多的假设。\r\n- [ ] 利用证伪假设的测试结果。\r\n- [ ] 用头脑风暴的方式找出可能的假设。\r\n- [ ] 在桌上放一个记事本,把需要尝试的事情列出来。\r\n- [ ] 缩小被怀疑有问题的代码区域。\r\n- [ ] 对之前出现过问题的类和子程序保持警惕。\r\n- [ ] 检查最近修改的代码。\r\n- [ ] 扩展被怀疑有问题的代码区域。\r\n- [ ] 采用增量集成。\r\n- [ ] 检查常见的缺陷。\r\n- [ ] 和其他人一起讨论你的问题。\r\n- [ ] 抛开问题休息一下。\r\n- [ ] 在使用快速肮脏调试法的时候,要设置一个时间上限。\r\n- [ ] 列出所有的蛮力调试方法,逐条应用。\r\n\r\n#### 解决语法错误的方法\r\n\r\n- [ ] 不要太信任编译器信息中给出的行号。\r\n- [ ] 不要太信任编译器信息。\r\n- [ ] 不要太信任编译器所给出的第二条出错信息。\r\n- [ ] 分而治之,各个击破。\r\n- [ ] 使用具有语法分析功能的编辑器来找出位置错误的注释和引号。\r\n\r\n#### 修正缺陷的方法\r\n\r\n- [ ] 在动手之前先理解程序。\r\n- [ ] 理解整个程序而非具体问题。\r\n- [ ] 验证对错误的分析。\r\n- [ ] 要保存最初的源代码。\r\n- [ ] 治本,而非治标。\r\n- [ ] 只有当理由充分的时候才去修改代码。\r\n- [ ] 一次只做一个改动。\r\n- [ ] 检查自己所做的修订。\r\n- [ ] 添加单元测试来暴露代码中的缺陷。\r\n- [ ] 找出类似的缺陷。\r\n\r\n#### 调试的一般方法\r\n\r\n- [ ] 你是否会把调试看做是能让你更好地理解程序、错误、代码质量和解决问题方法的良机?\r\n- [ ] 你是否会避免采用随机尝试查找错误或迷信式的调试方法?\r\n- [ ] 你是否假设错误是你自己造成的?\r\n- [ ] 你是否使用了科学的方法将间歇性的错误稳定下来?\r\n- [ ] 你是否使用了科学的方法来寻找缺陷?\r\n- [ ] 你在寻找缺陷的时候会使用多种不同的方法么?还是每次都是用相同的方法?\r\n- [ ] 你会验证你的修改是否正确么?\r\n- [ ] 你会在调试中使用编译器警告信息、执行性能分析、利用测试框架和交互式调试方法么?\r\n\r\n### Key Points 要点\r\n\r\n- 调试同整个软件开发的成败息息相关。最好的解决之道是使用本书中介绍的其他方法来避免缺陷的产生。然而,花点时间来提高自己的调试技能还是很划算的,因为优秀和拙劣的调试表现之间的差距至少是 10:1。\r\n- 要想成功,系统化地查找和改正错误的方法至关重要。要专注于你的调试工作,让每一次测试都能让你朝着正确的方向前进一步。要使用科学的调试方法。\r\n- 在动手解决问题之前,要理解问题的根本。胡乱猜测错误的来源和随机修改将会让你的程序陷入比刚开始调试时更为糟糕的境地。\r\n- 将编译器警告级别设置为最严格,把警告信息所报告的错误都改正。如果你忽略了明显的错误,那么要改正那些微妙的错误就会非常麻烦。\r\n- 调试工具对软件开发而言是强有力的支持手段。找出这些工具并加以应用,当然,请记得在调试的时候开动脑筋。",
    "sourceFile": "CHECKLISTS_DebuggingReminders.md",
    "chunkHash": "2c65a9a90b5753e8bce328347eeaa8bae6ab2e37cb4ed4a655619fc60bdc5ed4"
  },
  "1": {
    "text": "## CHECKLIST: A Quality-Assurance Plan\r\n\r\n### 核对表: 质量保证计划\r\n\r\n- [ ] 是否确定出对项目至关重要的特定质量特性了?\r\n- [ ] 是否让其他人意识到项目的质量目标了?\r\n- [ ] 是否能够区分质量的外在特性和内在特性?\r\n- [ ] 是否考虑过某些特性与其他特性相互制约或相互促进的具体方式?\r\n- [ ] 在软件开发的每一个阶段,项目是否要求针对不同错误类型使用不同的错误检测技术?\r\n- [ ] 项目计划中是否有计划有步骤地保证了软件在开发各阶段的质量?\r\n- [ ] 是否使用了某种质量评估方法,并由此确定质量是改善了还是下降了?\r\n- [ ] 管理层是否能理解为了质量保证在前期消耗额外成本,目的就是在项目后期减少成本?\r\n\r\n### Key Points 要点\r\n\r\n- 开发高质量代码最终并没有要求你付出更多,只是你需要对资源进行重新分配,以低廉的成本来防止缺陷出现,从而避免代价高昂的修正工作。\r\n- 并非所有的质量保证目标都可以全部实现。明确哪些目标是你希望达到的,并就这些目标和团队成员进行沟通。\r\n- 没有任何一种错误检测方法能够解决全部问题,测试本身并不是排除错误的最有效方法。成功的质量保证计划应该使用多种不同的技术来检查各种不同类型的错误。\r\n- 在构建期间应当使用一些有效的质量保证技术,但在这之前,一些具有同样强大功能的质量保证技术也是必不可少的。错误发现越早,它与其余代码的纠缠就越少,由此造成的损失也越小。\r\n- 软件领域的质量保证是面向过程的。软件开发与制造业不一样,在这里并不存在会影响最终产品的重复的阶段,因此,最终产品的质量受到开发软件所用的过程的控制。",
    "sourceFile": "CHECKLIST_AQuality-AssurancePlan.md",
    "chunkHash": "ef7cdb2467fb40f85e6a1452d96d232e9012e3601fffa57554f3b867a066287e"
  },
  "2": {
    "text": "## Checklist: Architecture\r\n\r\n### 核对表:架构\r\n\r\n以下是一份问题列表,优秀的架构应该关注这些问题。这张核对表的意图并非用做一份有关如何做架构的完全指南,而是作为一种实用的评估手段,用来评估软件食物链到了程序员这一头还有多少营养成分。这张核对表可用做你自己的核对表的出发点。就像\"需求\"的核对表一样,如果你从事的是非正式项目,那么你会发现其中某些条款甚至都不用去想。如果你从事的是更大型的项目,那么大多数条款都会是很有用的。\r\n\r\n#### 针对各架构主题\r\n\r\n- [ ] 程序的整体组织结构是否清晰?是否包含一个良好的架构全局观(及其理由)?\r\n- [ ] 是否明确定义了主要的构造块(包括每个构造块的职责范围及与其他构造块的接口)?\r\n- [ ] 是否明显涵盖了\"需求\"中列出的所有功能(每个功能对应的构造块不太多也不太少)?\r\n- [ ] 是否描述并论证了那些最关键的类?\r\n- [ ] 是否描述并论证了数据设计?\r\n- [ ] 是否详细定义了数据库的组织结构和内容?\r\n- [ ] 是否指出了所用关键的业务规则,并描述其对系统的影响?\r\n- [ ] 是否描述了用户界面设计的策略?\r\n- [ ] 是否将用户界面模块化,使界面的变更不会影响程序其余部分?\r\n- [ ] 是否描述并论证了处理 I/O 的策略?\r\n- [ ] 是否估算了稀缺资源(如线程、数据库连接、句柄、网络带宽等)的使用量,是否描述并论证了资源管理的策略?\r\n- [ ] 是否描述了架构的安全需求?\r\n- [ ] 架构是否为每个类、每个子系统、或每个功能域(functionality area)提出空间与时间预算?\r\n- [ ] 架构是否描述了如何达到可伸缩性?\r\n- [ ] 架构是否关注互操作性?\r\n- [ ] 是否描述了国际化/本地化的策略?\r\n- [ ] 是否提供了一套内聚的错误处理策略?\r\n- [ ] 是否规定了容错的办法(如果需要)?\r\n- [ ] 是否证实了系统各个部分的技术可行性?\r\n- [ ] 是否详细描述了过度工程(overengineering)的方法?\r\n- [ ] 是否包含了必要的\"买 vs.造\"的决策?\r\n- [ ] 架构是否描述了如何加工被复用的代码,使之符合其他架构目标?\r\n- [ ] 是否将架构设计得能够适应很可能出现的变更?\r\n\r\n#### 架构的总体质量\r\n\r\n- [ ] 架构是否解决了全部需求?\r\n- [ ] 有没有哪个部分是\"过度架构/overarchitected\"或\"欠架构/underarchitected\"?是否明确宣布了在这方面的预期指标?\r\n- [ ] 整个架构是否在概念上协调一致?\r\n- [ ] 顶层设计是否独立于用作实现它的机器和语言?\r\n- [ ] 是否说明了所有主要的决策的动机?\r\n- [ ] 你,作为一名实现该系统的程序员,是否对这个架构感觉良好?",
    "sourceFile": "Checklist_Architecture.md",
    "chunkHash": "d551ef1f89bb38b4b66247513dc9277d8a51418254e8dac42a2031fa74644fe2"
  },
  "3": {
    "text": "## CHECKLIST: Class Quality\r\n\r\n这是关于类的质量的考虑事项的核对表。\r\n\r\n### 核对表: 类的质量\r\n\r\n#### 抽象数据类型\r\n\r\n- [ ] 你是否把程序中的类都看做是抽象数据类型了?是否从这个角度评估它们的接口了?\r\n\r\n#### 抽象\r\n\r\n- [ ] 类是否有一个中心目的?\r\n- [ ] 类的命名是否恰当?其名字是否表达了其中心目的?\r\n- [ ] 类的接口是否展现了一致的抽象?\r\n- [ ] 类的接口是否能让人清楚明白地知道该如何用它?\r\n- [ ] 类的接口是否足够抽象,使你能不必顾虑它是如何实现其服务的?你能把类看做黑盒子吗?\r\n- [ ] 类提供的服务是否足够完整,能让其他类无须动用其内部数据?\r\n- [ ] 是否已从类中除去无关信息?\r\n- [ ] 是否考虑过把类进一步分解为组件类?是否已尽可能将其分解?\r\n- [ ] 在修改类时是否维持了其接口的完整性?\r\n\r\n#### 封装\r\n\r\n- [ ] 是否把类的成员的可访问性降到最小?\r\n- [ ] 是否避免暴露类中的数据成员?\r\n- [ ] 在编程语言所许可的范围内,类是否已尽可能地对其他的类隐藏了自己的实现细节?\r\n- [ ] 类是否避免对其使用者,包括其派生类会如何使用它做了假设?\r\n- [ ] 类是否不依赖于其他类?它是松散耦合的吗?\r\n\r\n#### 继承\r\n\r\n- [ ] 继承是否只用来建立\"是一个/is a\"的关系?也就是说,派生类是否遵循了LSP(Liskov替换原则)?\r\n- [ ] 类的文档中是否记述了其继承策略?\r\n- [ ] 派生类是否避免了\"覆盖\"不可覆盖的方法?\r\n- [ ] 是否把公用的接口、数据和行为都放到尽可能高的继承层次中了?\r\n- [ ] 继承层次是否很浅?\r\n- [ ] 基类中所有的数据成员是否都被定义为private而非protected的了?\r\n\r\n#### 跟实现相关的其他问题\r\n\r\n- [ ] 类中是否只有大约七个或更少的数据成员?\r\n- [ ] 是否把类直接或间接调用其他类的子程序的数量减到最少了?\r\n- [ ] 类是否只在绝对必要时才与其他的类相互协作?\r\n- [ ] 是否在构造函数中初始化了所有的数据成员?\r\n- [ ] 除非拥有经过测量的、创建浅层复本的理由,类是否都被设计为当作深层复本使用?\r\n\r\n#### 与语言相关的问题\r\n\r\n- [ ] 你是否研究过所用编程语言里和类相关的各种特有问题?\r\n\r\n### Key Points 要点\r\n\r\n- 类的接口应提供一致的抽象。很多问题都是由于违背该原则而引起的。\r\n- 类的接口应隐藏一些信息——如某个系统接口、某项设计决策、或一些实现细节。\r\n- 包含往往比继承更为可取——除非你要对\"是一个/isa\"的关系建模。\r\n- 继承是一种有用的工具,但它却会增加复杂度,这有违于软件的首要技术使命——管理复杂度。\r\n- 类是管理复杂度的首选工具。要在设计类时给予足够的关注,才能实现这一目标。",
    "sourceFile": "CHECKLIST_ClassQuality.md",
    "chunkHash": "ad59a9a08a41d0c0d8c2d0cbdb0d32a1e8ea2a1148bd83f679e1f6a0502b09f4"
  },
  "4": {
    "text": "## CHECKLIST: Code-Tuning Strategies\r\n\r\n### 核对表: 代码调整策略\r\n\r\n#### 程序整体性能\r\n\r\n- [ ] 你是否考虑通过修改需求来提高性能?\r\n- [ ] 你是否考虑通过修改程序的设计来提高性能?\r\n- [ ] 你是否考虑通过修改类的设计来提高性能?\r\n- [ ] 你是否考虑过减少程序同操作系统的交互从而提高性能?\r\n- [ ] 是否考虑过避免 I/O 操作以提高性能?\r\n- [ ] 是否考虑使用编译型语言替代解释型语言以提高性能?\r\n- [ ] 是否考虑过使用编译器优化选项来提高性能?\r\n- [ ] 是否考虑过使用不同的硬件来提高性能?\r\n- [ ] 是否仅仅将代码调整看做是解决问题的最后一招?\r\n\r\n#### 代码调整方法\r\n\r\n- [ ] 在开始调整代码之前,程序是完全正确的么?\r\n- [ ] 在调整之前是否测量过性能瓶颈在什么地方?\r\n- [ ] 是否记录了每一次修改所产生的效果?\r\n- [ ] 如果没有带来预期的性能提高,你是否放弃了所做的代码调整改变?\r\n- [ ] 你是否对每一个性能瓶颈进行不止一次的修改尝试——也就是说,你是在反复进行代码调整么?\r\n\r\n### Key Points 要点\r\n\r\n- 性能只是软件整体质量的一个方面,通常不是最重要的。精细的代码调整也只是实现整体性能的一种方法,通常也不是决定性的。相对于代码本身的效率而言,程序的架构、细节设计以及数据结构和算法选择对程序的运行速度和资源占用的影响通常会更大。\r\n- 定量测量是实现性能最优化的关键。定量测量需要找出能真正决定程序性能的部分,在修改之后,应当通过重复测量来明确修改是提高还是降低了软件的性能。\r\n- 绝大多数的程序都有那么一小部分代码耗费了绝大部分的运行时间。如果没有测量,你不会知道是哪一部分代码。\r\n- 代码调整需要反复尝试,这样才能获得理想的性能提高。\r\n- 为性能优化工作做好准备的最佳方式就是在最初阶段编写清晰的代码,从而使代码在后续工作中易于理解和修改。",
    "sourceFile": "CHECKLIST_Code-TuningStrategies.md",
    "chunkHash": "6df657d7c85b5a7ae3999390ca77be7fb7d93b65b1387933fd652da12cfb3de8"
  },
  "5": {
    "text": "## CHECKLIST: Code-Tuning Techniques\r\n\r\n### 核对表: 代码调整方法\r\n\r\n#### 同时改善代码执行速度和规模\r\n\r\n- [ ] 用查询表替换复杂逻辑。\r\n- [ ] 合并循环。\r\n- [ ] 使用整型变量而非浮点变量。\r\n- [ ] 在编译时初始化数据。\r\n- [ ] 使用正确的常量类型。\r\n- [ ] 预先计算结果。\r\n- [ ] 删除公共子表达式。\r\n- [ ] 将关键子程序代码转化为某种低级语言代码。\r\n\r\n#### 仅仅提高代码执行速度\r\n\r\n- [ ] 在知道答案后就停止执行判断。\r\n- [ ] 根据各种情况的出现频率对 case 语句和 if- then- else 串排序。\r\n- [ ] 比较相似逻辑结构的性能。\r\n- [ ] 使用情性求值。\r\n- [ ] 将循环中的 if 判断转到外部。\r\n- [ ] 展开循环。\r\n- [ ] 将循环内部所做的工作减少到最低限度。\r\n- [ ] 在查找循环中使用哨兵。\r\n- [ ] 把执行最为频繁的循环放在嵌套循环的最里面。\r\n- [ ] 减轻内层循环的强度。\r\n- [ ] 将多维数组改为一维数组。\r\n- [ ] 最大限度减少数组索引。\r\n- [ ] 为数据类型扩充索引。\r\n- [ ] 对频繁使用的值进行缓存。\r\n- [ ] 利用代数恒等式。\r\n- [ ] 降低逻辑和数学表达式的强度。\r\n- [ ] 注意系统调用。\r\n- [ ] 用内联子程序重写代码。\r\n\r\n# Key Points 要点\r\n\r\n- 优化结果在不同的语言、编译器和环境下有很大差异。如果没有对每一次的优化进行测量,你将无法判断优化到底是帮助还是损害了这个程序。\r\n- 第一次优化通常不会是最好的。即使找到了效果很不错的,也不要停下扩大战果的步伐。\r\n- 代码调整这一话题有点类似于核能,富有争议,甚至会让人冲动。一些人认为代码调整损害了代码可读性和可维护性,他们绝对会将其弃之不用。其他人则认为只要有适当的安全保障,代码调整对程序是有益的。如果你决定使用本章所述的调整方法,请务必谨慎行事。",
    "sourceFile": "CHECKLIST_Code-TuningTechniques.md",
    "chunkHash": "b75c3f3a19811bdc6dc02db8de31101439d390bad1de0386602fed55440817e6"
  },
  "6": {
    "text": "## CHECKLIST: Configuration Management\r\n\r\n### 核对表: 配置管理\r\n\r\n#### 概要\r\n\r\n- [ ] 你的软件配置管理计划是否用于帮助程序员,并能将额外负担降至最低?\r\n- [ ] 你的软件配置管理方法是否避免了对项目的过度控制?\r\n- [ ] 你是否将一些变更请求聚成一组?无论采用非正式的方法(如创建一份未决更改的列表)还是更加系统的方法(如设立变更控制委员会)。\r\n- [ ] 你系统地评估了每一项提交的更改对成本、计划和质量的影响吗?\r\n- [ ] 你是否把重大的变更看做是需求分析还不够完备的警报信号?\r\n\r\n#### 工具\r\n\r\n- [ ] 你用版本控制软件来促进配置管理吗?\r\n- [ ] 你用版本控制软件来减少团队工作中的协调问题吗?\r\n\r\n#### 备份\r\n\r\n- [ ] 你定期地备份项目中的所有资料吗?\r\n- [ ] 你定期地把项目备份数据转移到 off- site storage 里了吗?\r\n- [ ] 所有的资料,包括源代码、文档、图表和重要的笔记都得到备份了吗?\r\n- [ ] 你测试过备份与恢复的过程吗?",
    "sourceFile": "CHECKLIST_ConfigurationManagement.md",
    "chunkHash": "42bad2b8bccc761458446fd1e709d1efd40bc753522b94cc55bfdd94c69a4cc7"
  },
  "7": {
    "text": "## CHECKLIST: Considerations in Using Unusual Data Types\r\n\r\n### 核对表: 使用不常见数据类型的注意事项\r\n\r\n#### 结构体\r\n\r\n- [ ] 你使用结构体而不是使用单纯的变量来组织和操作相关的数据吗?\r\n- [ ] 你考虑创建一个类来代替使用结构体吗?\r\n\r\n#### 全局数据\r\n\r\n- [ ] 所有的变量是否都是局部的或者是类范围的?除非绝对有必要才是全局的?\r\n- [ ] 变量的命名规则能把局部数据、类数据和全局数据区分开吗?\r\n- [ ] 你对所有的全局变量都加以文档说明吗?\r\n- [ ] 避免使用伪全局数据,即被四处传递且包含有杂乱数据的巨大对象吗?\r\n- [ ] 用访问器子程序来取代全局数据吗?\r\n- [ ] 把访问器子程序和数据组织到类里面吗?\r\n- [ ] 访问器子程序提供了一个在底层数据类型实现之上的抽象层吗?\r\n- [ ] 所有相关的访问器子程序都位于同一抽象层之上吗?\r\n\r\n#### 指针\r\n\r\n- [ ] 把指针操作隔离在子程序里吗?\r\n- [ ] 指针引用合法吗?或者说指针有可能成为空悬指针吗?\r\n- [ ] 代码在使用指针之前检查它的有效性吗?\r\n- [ ] 在使用指针所指向的变量之前检查其有效性吗?\r\n- [ ] 指针用完后被设置为空值吗?\r\n- [ ] 就可读性而言,代码用了所有需要使用的指针变量吗?\r\n- [ ] 链表中的指针是按正确的顺序加以释放吗?\r\n- [ ] 程序分配了一片保留的内存后备区域,以便在耗尽内存的时候能够优雅地退出吗?\r\n- [ ] 是不是在没有其他方法可用的情况下最终才使用指针的?\r\n\r\n### Key Points 要点\r\n\r\n- 结构体可以使得程序更简单、更容易理解,以及更容易维护。\r\n- 每当你打算使用结构体的时候,考虑采用类是不是会工作得更好。\r\n- 指针很容易出错。用访问器子程序或类以及防御式编程实践来保护自己的代码。\r\n- 避免用全局变量,不只是因为它们很危险,还是因为你可以用其他更好的方法来取代它们。\r\n- 如果你不得不使用全局变量,那么就通过访问器子程序来使用它。访问器子程序能为你带来全局变量所能带来的一切优点,还有一些额外好处。",
    "sourceFile": "CHECKLIST_ConsiderationsinUsingUnusualDataTypes.md",
    "chunkHash": "feaee88f7d7e6bf0708daa2bbcaa6bb8ec65e8d9ca6b77a21c788c61ef5f8c29"
  },
  "8": {
    "text": "## CHECKLIST: Control-Structure Issues\r\n\r\n### 核对表: 控制结构相关事宜\r\n\r\n- [ ] 表达式中用的是 true 和 false,而不是 1 和 0 吗?\r\n- [ ] 布尔值和 true 以及 false 做比较是隐式进行的吗?\r\n- [ ] 对数值做比较是显式进行的吗?\r\n- [ ] 有没有通过增加新的布尔变量、使用布尔函数和决策表来简化表达式?\r\n- [ ] 布尔表达式是用肯定形式表达的吗?\r\n- [ ] 括号配对吗?\r\n- [ ] 在需要用括号来明确的地方都使用了括号吗?\r\n- [ ] 把逻辑表达式全括起来了吗?\r\n- [ ] 判断是按照数轴顺序编写的吗?\r\n- [ ] 如果适当的话,Java 中的判断用的是 a.equals(b)方式,而没有用  $a = =b$  方式吗?\r\n- [ ] 空语句表述得明显吗?\r\n- [ ] 用重新判断部分条件、转换成 if- then- else 或者 case 语句、把嵌套代码提取成单独的子程序、换用一种更面向对象的设计或者其他的改进方法来简化嵌套语句了吗?\r\n- [ ] 如果一个子程序的决策点超过 10 个,那么能提出不重新设计的理由吗?\r\n\r\n### Key Points 要点\r\n\r\n- 使布尔表达式简单可读, 将非常有助于提高你的代码的质量。\r\n- 深层次的嵌套使得子程序变得难以理解。所幸的是, 你可以相对容易地避免这么做。\r\n- 结构化编程是一种简单并且仍然适用的思想: 你可以通过把顺序、选择和循环三者组合起来而开发出任何程序。\r\n- 将复杂度降低到最低水平是编写高质量代码的关键。",
    "sourceFile": "CHECKLIST_Control-StructureIssues.md",
    "chunkHash": "e376fbbe8477e775aa0d45ff474c87bd01f736db03dde2f21fe26ab1a5a012b6"
  },
  "9": {
    "text": "## CHECKLIST: Defensive Programming\r\n\r\n### 核对表: 防御式编程\r\n\r\n#### 一般事宜\r\n\r\n- [ ] 子程序是否保护自己免遭有害输入数据的破坏?\r\n- [ ] 你用断言来说明编程假定吗?其中包括了前条件和后条件吗?\r\n- [ ] 断言是否只是用来说明从不应该发生的情况?\r\n- [ ] 你是否在架构或高层设计中规定了一组特定的错误处理技术?\r\n- [ ] 你是否在架构或高层设计中规定了是让错误处理更倾向于健壮性还是正确性?\r\n- [ ] 你是否建立了隔栏来遏制错误可能造成的破坏?是否减少了其他需要关注错误处理的代码的数量?\r\n- [ ] 代码中用到辅助调试的代码了吗?\r\n- [ ] 如果需要启用或禁用添加的辅助助子的话,是否无须大动干戈?\r\n- [ ] 在防御式编程时引入的代码量是否适宜——既不过多,也不过少?\r\n- [ ] 你在开发阶段是否采用了进攻式编程来使错误难以被忽视?\r\n\r\n#### 异常\r\n\r\n- [ ] 你在项目中定义了一套标准化的异常处理方案吗?\r\n- [ ] 是否考虑过异常之外的其他替代方案?\r\n- [ ] 如果可能的话,是否在局部处理了错误而不是把它当成一个异常抛到外部?\r\n- [ ] 代码中是否避免了在构造函数和析构函数中抛出异常?\r\n- [ ] 所有的异常是否都与抛出它们的子程序处于同一抽象层次上?\r\n- [ ] 每个异常是否都包含了关于异常发生的所有背景信息?\r\n- [ ] 代码中是否没有使用空的 catch 语句?(或者如果使用空的 catch 语句确实很合适,那么明确说明了吗?)\r\n\r\n#### 安全事宜\r\n\r\n- [ ] 检查有害输入数据的代码是否也检查了故意的缓冲区溢出、SQL 注入、HTML 注入、整数溢出以及其他恶意输入数据?\r\n- [ ] 是否检查了所有的错误返回码?\r\n- [ ] 是否捕获了所有的异常?\r\n- [ ] 出错消息中是否避免出现有助于攻击者攻入系统所需的信息?\r\n\r\n### Key Points 要点\r\n\r\n- 最终产品代码中对错误的处理方式要比\"垃圾进,垃圾出\"复杂得多。\r\n- 防御式编程技术可以让错误更容易发现、更容易修改,并减少错误对产品代码的破坏。\r\n- 断言可以帮助人尽早发现错误,尤其是在大型系统和高可靠性的系统中,以及快速变化的代码中。\r\n- 关于如何处理错误输入的决策是一项关键的错误处理决策,也是一项关键的高层设计决策。\r\n- 异常提供了一种与代码正常流程角度不同的错误处理手段。如果留心使用异常,它可以成为程序员们知识工具箱中的一项有益补充,同时也应该在异常和其他错误处理手段之间进行权衡比较。\r\n- 针对产品代码的限制并不适用于开发中的软件。你可以利用这一优势在开发中添加有助于更快地排查错误的代码。",
    "sourceFile": "CHECKLIST_DefensiveProgramming.md",
    "chunkHash": "c3e8a95dc0f6f46c3a085a7c3758bddf46ce02b3ae7aba8c7fb2059aecfd4c88"
  },
  "10": {
    "text": "## CHECKLIST: Design In Construction\r\n\r\n### 核对表:软件构造中的设计\r\n\r\n#### 设计实践\r\n\r\n- [ ] 你已经做过多次迭代,并且从众多尝试结果中选择最佳的一种,而不是简单选择第一次尝试的结果吗?\r\n- [ ] 你尝试用多种方案来分解系统,以确定最佳方案吗?\r\n- [ ] 你同时用自下而上和自上而下的方法来解决设计问题吗?\r\n- [ ] 为了解决某些特定的问题,你对系统中的风险部分或者不熟悉的部分创建过原型、写出数量最少的可抛弃的代码吗?\r\n- [ ] 你的设计方案被其他人检查了吗(无论正式与否)?\r\n- [ ] 你一直在展开设计,直到实施细节跃然纸上了吗?\r\n- [ ] 你用某种适当的技术——比如说 Wiki、电子邮件、挂图、数码照片、UML、CRC 卡或者在代码写注释——来保留设计成果吗?\r\n\r\n#### 设计目标\r\n\r\n- [ ] 你的设计是否充分地处理了由系统架构层定义出并且推迟确定的事项?\r\n- [ ] 你的设计被划分为层次吗?\r\n- [ ] 你对把这一程序分解成为子程序、包和类的方式感到满意吗?\r\n- [ ] 你把对这个类分解成为子程序的方法感到满意吗?\r\n- [ ] 类与类之间的交互关系是否已设计为最小化了?\r\n- [ ] 类和子程序是否被设计为能够在其他的系统中重用?\r\n- [ ] 程序是不是易于维护?\r\n- [ ] 设计是否精简?设计出来的每一部分都绝对必要吗?\r\n- [ ] 设计中是否采用了标准的技术?是否避免使用怪异且难以理解的元素?\r\n- [ ] 整体而言,你的设计是否有助于最小化偶然性的和本质性的复杂度吗?\r\n\r\n### Key Points 要点\r\n\r\n- 软件的首要技术使命就是管理复杂度。以简单性作为努力目标的设计方案对此最有帮助。\r\n- 简单性可以通过两种方式来获取:一是减少在同一时间所关注的本质性复杂度的量,二是避免生成不必要的偶然的复杂度。\r\n- 设计是一种启发式的过程。固执于某一种单一方法会损害创新能力,从而损害你的程序。\r\n- 好的设计都是迭代的。你会试设计的可能性越多,你的最终设计方案就会变得越好。\r\n- 信息隐藏是个非常有价值的概念。通过询问\"我应该隐藏些什么?\"能够解决很多困难的设计问题。\r\n- 很多有用有趣的、关于设计的信息存在于本书之外。这里所给出的观点只是对这些有价值资源的一点提示而已。",
    "sourceFile": "CHECKLIST_DesignInConstruction.md",
    "chunkHash": "db0e7d3cd3cff24e4899c7da628deb93bc6426cf35d5ed5343fc1bae7d343aa9"
  },
  "11": {
    "text": "## CHECKLIST: Effective Inspections\r\n\r\n### 核对表: 有效的详查\r\n\r\n- [ ] 你是否有一个核对表,能让评论员将注意力集中于曾经发生过问题的领域?\r\n- [ ] 你是否专注于找出错误,而不是修正它们?\r\n- [ ] 你是否考虑制定某些视角或者场景,以帮助评论员在准备工作的时候集中注意力?\r\n- [ ] 你是否给予评论员足够的时间在详查会议之前进行准备,是否每一个人都做了准备?\r\n- [ ] 是否每一个参与者都扮演一个明确的角色——主持人、评论员及记录员等?\r\n- [ ] 会议是否以某种高效的速度进行?\r\n- [ ] 会议是否限制在两个小时以内?\r\n- [ ] 是否所有详查会议的参与者都接受了如何进行详查的针对性培训,是否主持人接受了有关主持技巧方面的针对性培训?\r\n- [ ] 是否将每次详查所发现的错误数据都收集起来,使你能调整本组织以后使用的核对表?\r\n- [ ] 是否收集了准备速度和详查速度方面的数据,以便你去优化以后的准备和详查工作?\r\n- [ ] 是否每次详查中被指派下去的活动都被正确跟进了,无论是通过主持人自己还是一次重新详查?\r\n- [ ] 管理层是否理解他们不应该参与详查会议?\r\n- [ ] 是否有一个用于保证修正正确性的跟进计划?\r\n\r\n### Key Points 要点\r\n\r\n- 协同开发实践往往能比测试发现更多的缺陷,并且更有效率。\r\n- 协同开发实践所发现错误的类型通常跟测试所发现的不同,这意味着你需要同时使用详查和测试来保证你软件的质量。\r\n- 正式检查通过运用核对表、准备工作、明确定义的角色以及对方法的持续改善,将缺陷侦测的效率提升至最高。它往往能比走查发现更多的缺陷。\r\n- 通常,结对编程拥有和详查相同的成本,并能产生质量相当的代码。当需要缩短开发周期的时候,结对编程就非常有价值。相对于单独工作来说,有些开发人员更喜欢结对工作。\r\n- 正式检查可以应用在除代码之外的很多工作成果上,例如需求、设计以及测试用例等。\r\n- 走查和代码阅读是详查的替代方案。代码阅读更富有弹性,能有效地利用每个人的时间。",
    "sourceFile": "CHECKLIST_EffectiveInspections.md",
    "chunkHash": "b932071e3106c21d9fc0a5d1532191d4172db3082dc2dcfce2999c1154674ff6"
  },
  "12": {
    "text": "## CHECKLIST: Effective Pair Programming\r\n\r\n### 核对表: 有效的结对编程\r\n\r\n- [ ] 是否已经有一个编码规范,以便让程序员始终把精力集中到编程,而不是编码风格的讨论上?\r\n- [ ] 结对的双方是否都积极地参与?\r\n- [ ] 是否避免了滥用结对编程,而是选择那些能够从中获得好处的工作进行结对编程?\r\n- [ ] 是否有规律地对人员和工作任务进行轮换?\r\n- [ ] 结对组合是否在开发速度和个性方面互相匹配?\r\n- [ ] 是否有一个组长专注于项目管理以及与项目外其他人的沟通?",
    "sourceFile": "CHECKLIST_EffectivePairProgramming.md",
    "chunkHash": "88b25aae4fe98754153c91e411d630b37f673419d90515fd0cedf33bb137e94f"
  },
  "13": {
    "text": "## CHECKLIST: Fundamental Data\r\n\r\n### 核对表: 基本数据类型\r\n\r\n#### 数值概论\r\n\r\n- [ ] 代码中避免使用神秘数值吗?\r\n- [ ] 代码考虑了除零错误吗?\r\n- [ ] 类型转换很明显吗?\r\n- [ ] 如果在一条语句中存在两个不同类型的变量, 那么这条语句会像你期望的那样求值吗?\r\n- [ ] 代码避免了混合类型比较吗?\r\n- [ ] 程序编译时没有警告信息吗?\r\n\r\n#### 整数\r\n\r\n- [ ] 使用整数除法的表达式能按预期的那样工作吗?\r\n- [ ] 整数表达式避免整数溢出问题吗?\r\n\r\n#### 浮点数\r\n\r\n- [ ] 代码避免了对数量级相差巨大的数字做加减运算吗?\r\n- [ ] 代码系统地阻止了舍入错误的发生吗?\r\n- [ ] 代码避免对浮点数做等量比较吗?\r\n\r\n#### 字符和字符串\r\n\r\n- [ ] 代码避免使用神秘字符和神秘字符串吗?\r\n- [ ] 使用字符串时避免了 off- by- one 错误吗?\r\n- [ ] C 代码把字符串指针和字符数组区别对待了吗?\r\n- [ ] C 代码遵循了把字符串声明为 CONST+1 长度的规则了吗?\r\n- [ ] C 代码在适当的时候用字符数组来代替指针了吗?\r\n- [ ] C 代码把字符串初始化为 NULL 来避免无终端的字符串了吗?\r\n- [ ] C 代码用 strncpy()代替 strcpy()吗?strncat()和 strncmp()呢?\r\n\r\n#### 布尔变量\r\n\r\n- [ ] 程序用额外的布尔变量来说明条件判断了吗?\r\n- [ ] 程序用额外的布尔变量来简化条件判断了吗?\r\n\r\n#### 枚举类型\r\n\r\n- [ ] 程序用枚举类型而非具名常量来提高可读性、可靠性和可修改性吗?\r\n- [ ] 当变量的用法不能仅用 true 和 false 表示的时候,程序用枚举类型来取代布尔变量吗?\r\n- [ ] 针对枚举类型的测试检测了非法数值吗?\r\n- [ ] 把枚举类型的第一项条目保留为\"非法的\"了吗?\r\n\r\n#### 具名常量\r\n\r\n- [ ] 程序用具名常量而不是神秘数值来声明数据和表示循环界限吗?\r\n- [ ] 具名常量的使用一致吗?没有在有些位置使用具名常量又在其他位置使用文字量?\r\n\r\n#### 数组\r\n\r\n- [ ] 所有的数组下标都没有超出数组边界吗?\r\n- [ ] 数组引用没有出现 off- by- one 错误吗?\r\n- [ ] 所有多维数组的下标的顺序都正确吗?\r\n- [ ] 在嵌套循环里,把正确的变量用于数组下标来避免循环下标串话了吗?\r\n\r\n#### 创建类型\r\n\r\n- [ ] 程序对每一种可能变化的数据分别采用不同的类型吗?\r\n- [ ] 类型名是以该类型所表示的现实世界实体为导向,而不是以编程语言类型为导向的吗?\r\n- [ ] 类型名的描述性足以强,可以帮助解释数据声明吗?\r\n- [ ] 你避免重新定义预定义类型吗?\r\n- [ ] 与简单地重定义一个类型相比,你考虑过创建一个新类吗?\r\n\r\n### Key Points 要点\r\n\r\n- 使用特定的数据类型就意味着要记住适用于各个类型的很多独立的原则。用本章的核对表来确认你已经对常见问题做了考虑。\r\n- 如果你的语言支持,创建自定义类型会使得你的程序更容易修改,并更具有白描述性。\r\n- 当你用 typedef 或者其等价方式创建了一个简单类型的时候,考虑是否更应该创建一个新的类。",
    "sourceFile": "CHECKLIST_FundamentalData.md",
    "chunkHash": "59a01307b970a8a61a11246a67be3ee2feddd4b0aebfae0af478cf2defcab8a8"
  },
  "14": {
    "text": "## CHECKLIST: General Considerations In Using Data\r\n\r\n### 核对表: 使用数据的一般事项\r\n\r\n#### 初始化变量\r\n\r\n- [ ] 每一个子程序都检查其输入参数的正确性吗?\r\n- [ ] 变量声明位置靠近变量第一次使用的位置吗?\r\n- [ ] 尽可能地在声明变量的同时初始化变量吗?\r\n- [ ] 如果无法同时声明和初始化变量,有没有在靠近第一次使用变量的位置声明变量?\r\n- [ ] 计数器和累加器经过了适当的初始化吗?如果需要再一次使用,之前重新初始化了吗?\r\n- [ ] 适当地重新初始化\"需要重复执行的代码里的变量\"了吗?\r\n- [ ] 代码在通过编译器编译的时候是不是没有警告信息?(你启用了所有可用的警告选项了吗?)\r\n- [ ] 如果你用的语言允许隐式声明,你为由此可能引发的问题做好补偿措施了吗?\r\n\r\n#### 使用数据的其他事项\r\n\r\n- [ ] 如果可能,所有变量都被定义为具有最小的作用域吗?\r\n- [ ] 各变量的引用点都尽可能集中在一起吗?对同一变量的两次相邻引用,或者变量的整个生命期都这样做了吗?\r\n- [ ] 控制结构符合数据类型吗?\r\n- [ ] 所有声明的变量都用到了吗?\r\n- [ ] 变量都在合适的时间绑定了吗?——也就是说,你有意识地在晚期绑定所带来的灵活性和增加的复杂度之间做出平衡了吗?每个变量都有且仅有一项用途吗?每个变量的含义都很明确且没有隐含含义吗?\r\n\r\n### Key Points 要点\r\n\r\n- 数据初始化过程很容易出错,所以请用本章描述的初始化方法来避免由于非预期的初始值而造成的错误。\r\n- 最小化每个变量的作用域。把同一变量的引用点集中在一起。把变量限定在子程序或类的范围之内。避免使用全局数据。\r\n- 把使用相同变量的语句尽可能集中在一起。\r\n- 早期绑定会减低灵活性,但有助于减小复杂度。晚期绑定可以增加灵活性,同时增加复杂度。\r\n- 把每个变量用于唯一的用途。",
    "sourceFile": "CHECKLIST_GeneralConsiderationsInUsingData.md",
    "chunkHash": "cb88d47c6db03d442ff42a4191bfa1634ccd35b594fee4f3bf776ee5dd5a8f87"
  },
  "15": {
    "text": "## CHECKLIST: Good Commenting Technique\r\n\r\n### 检查表: 好的注释技术\r\n\r\n#### 一般问题\r\n\r\n- [ ] 别人拿起你的代码就能立刻明白其意吗?\r\n- [ ] 你的注释是在解释代码用意,或概括代码在做什么,而非简单重复代码吗?\r\n- [ ] 采用了伪代码编程法来减少注释时间吗?\r\n- [ ] 是重写有玄机的代码,而非为其做注释吗?\r\n- [ ] 你的注释能否同代码一起更新?\r\n- [ ] 注释清楚正确吗?\r\n- [ ] 你的注释风格便于修改注释吗?\r\n\r\n#### 语句和段落\r\n\r\n- [ ] 代码避免用行尾注释了吗?\r\n- [ ] 注释是着力说明为什么而非怎么样吗?\r\n- [ ] 注释为将要阅读代码的人们做好准备了吗?\r\n- [ ] 每个注释都其用处吗?删掉抑或改进了多余的、无关紧要的或随意的注释没有?\r\n- [ ] 是否注释了代码的非常规之处?\r\n- [ ] 避免使用缩略语了吗?\r\n- [ ] 主次注释区别明显吗?\r\n- [ ] 含错代码和未公开的代码特性有注释吗?\r\n\r\n#### 数据声明\r\n\r\n- [ ] 对数据声明的注释说明了数值单位吗?\r\n- [ ] 数值数据的取值范围注释出来了吗?\r\n- [ ] 注释出了编码含义吗?\r\n- [ ] 对输入数据的限制有注释吗?\r\n- [ ] 对位标志做注释了吗?\r\n- [ ] 在各全局变量声明的地方对其做注释了吗?\r\n- [ ] 各全局变量是通过命名规范、注释(或者两者兼用)来标识其意义吗?\r\n- [ ] 神秘数值是否以具名常量或变量代替,而非只是标注之?\r\n\r\n#### 控制结构\r\n\r\n- [ ] 控制语句都注释了吗?\r\n- [ ] 冗长或者复杂的控制结构结尾处有注释吗?抑或可能的话,简化之从而省去注释了吗?\r\n\r\n#### 子程序\r\n\r\n- [ ] 子程序各子程序的意图都注释出了吗?\r\n- [ ] 子程序的其他有关情况(诸如输入输出数据、接口假设、局限性、纠错、全局效果和算法来源)都注释出来了吗?\r\n\r\n#### 文件、类和程序\r\n\r\n- [ ] 程序有简短的文档(就像在\"以书本为范例\"中说明的那样)给出程序组织的概述吗?\r\n- [ ] 每个文件的用途都有说明吗?\r\n- [ ] 作者姓名、email 及电话号码在代码清单中都有吗?\r\n\r\n### Key Points 要点\r\n\r\n- 该不该注释是个需要认真对待的问题。差劲的注释只会浪费时间,帮倒忙;好的注释才有价值。\r\n- 源代码应当含有程序大部分的关键信息。只要程序依然在用,源代码比其他资料都能保持更新,故而将重要信息融入代码是很有用处的。\r\n- 好代码本身就是最好的说明。如果代码太糟,需要大量注释,应先试着改进代码,直至无须过多注释为止。\r\n- 注释应说出代码无法说出的东西——例如概述或用意等信息。\r\n- 有的注释风格需要许多重复性劳动,应舍弃之,改用易于维护的注释风格。",
    "sourceFile": "CHECKLIST_GoodCommentingTechnique.md",
    "chunkHash": "87f4841976c3d6625b07569463b2ac50bca09055041897ad80db0758dc9dd971"
  },
  "16": {
    "text": "## CHECKLIST: High-Quality Routines\r\n\r\n### 核对表: 高质量的子程序\r\n\r\n这是一份针对子程序质量所要考查事项的核对表。\r\n\r\n#### 大局事项\r\n\r\n- [ ] 创建子程序的理由充分吗?\r\n- [ ] 一个子程序中所有适于单独提出的部分是不是已经被提出到单独的子程序中了?\r\n- [ ] 过程的名字中是否用了强烈、清晰的\"动词十宾语\"词组? 函数的名字是否描述了其返回值?\r\n- [ ] 子程序的名字是否描述了它所做的全部事情?\r\n- [ ] 是否给常用的操作建立了命名规则?\r\n- [ ] 子程序是否具有强烈的功能上的内聚性? 即它是否做且只做一件事, 并且把它做得很好?\r\n- [ ] 子程序之间是否有较松的耦合? 子程序与其他子程序之间的连接是否是小的 (small)、明确的 (intimate)、可见的 (viaible) 和灵活的 (flexible)?\r\n- [ ] 子程序的长度是否是由其功能和逻辑自然确定, 而非遵循任何人为的编码标准?\r\n\r\n#### 参数传递事宜\r\n\r\n- [ ] 整体来看, 子程序的参数表是否表现出一种具有整体性且一致的接口抽象?\r\n- [ ] 子程序参数的排列顺序是否合理? 是否与类似的子程序的参数排列顺序相符?\r\n- [ ] 接口假定是否已在文档中说明?\r\n- [ ] 子程序的参数个数是否没超过 7 个?\r\n- [ ] 是否用到了每一个输入参数?\r\n- [ ] 是否用到了每一个输出参数?\r\n- [ ] 子程序是否避免了把输入参数用做工作变量?\r\n- [ ] 如果子程序是一个函数, 那么它是否在所有可能的情况下都能返回一个合法的值?\r\n\r\n### Key Points 要点\r\n\r\n- 创建子程序最主要的目的是提高程序的可管理性, 当然也有其他一些好的理由。其中, 节省代码空间只是一个次要原因; 提高可读性、可靠性和可修改性等原因都更重要一些。\r\n- 有时候, 把一些简单的操作写成独立的子程序也非常有价值。\r\n- 子程序可以按照其内聚性分为很多类, 而你应该让大多数子程序具有功能上的内聚性, 这是最佳的一种内聚性。\r\n- 子程序的名字是它的质量的指示器。如果名字糟糕但恰如其分, 那就说明这个子程序设计得很差劲。如果名字糟糕而且又不准确, 那么它就反映不出程序是干什么的。不管怎样, 糟糕的名字都意味着程序需要修改。\r\n- 只有在某个子程序的主要目的是返回由其名字所描述的特定结果时, 才应该使用函数。\r\n- 细心的程序员会非常谨慎地使用宏, 而且只在万不得已时才用。",
    "sourceFile": "CHECKLIST_High-QualityRoutines.md",
    "chunkHash": "db0dd2be2555c436d9333dac4b4d6210a57626edbde1dd2e9bb8fa20499eaf77"
  },
  "17": {
    "text": "## CHECKLIST: Integration\r\n\r\n### 核对表: 集成\r\n\r\n#### 集成策略\r\n\r\n- [ ] 该策略是否指明了集成子系统、类、子程序时应该采用的最优顺序?\r\n- [ ] 集成的顺序是否与构建顺序协调,以便在适当的时候准备好供集成的类?\r\n- [ ] 该策略是否易于诊断缺陷?\r\n- [ ] 该策略是否使脚手架最少?\r\n- [ ] 所选的策略是否好于其他方式?\r\n- [ ] 组件之间的接口是否有明确定义?(定义接口不是集成的任务,但要验证这些接口的定义是否明确。)\r\n\r\n#### Dailybuild 与冒烟测试\r\n\r\n- [ ] 项目是否经常 build——理想情况下,每天 build 一次——以支持增量集成?\r\n- [ ] 每次 build 后是否都运行冒烟测试,让你知道这个 build 能否工作?\r\n- [ ] 你是否已使 build 和冒烟测试自动进行?\r\n- [ ] 开发人员是否频繁地 checkin 他们的代码——两次 checkin 之间最多间隔一两天?\r\n- [ ] 冒烟测试是否与代码同步更新,随代码发展而发展?\r\n- [ ] 破坏 build 是罕见事件吗?\r\n- [ ] 是否在有压力的情况下,也对软件进行 build 和冒烟测试?\r\n\r\n#### Key Points 要点\r\n\r\n- 构建的先后次序和集成的步骤会影响设计、编码、测试各类的顺序。\r\n- 一个经过充分思考的集成顺序能减少测试的工作量,并使调试变容易。\r\n- 增量集成有若干变型,而且——除非项目是微不足道的——任何一种形式的增量集成都比阶段式集成好。\r\n- 针对每个特定的项目,最佳的集成步骤通常是自顶向下、自底向上、风险导向及其他集成方法的某种组合。T- 型集成和竖直分块集成通常都能工作得很好。\r\n- daily build 能减少集成的问题,提升开发人员的士气,并提供非常有用的项目管理信息。",
    "sourceFile": "CHECKLIST_Integration.md",
    "chunkHash": "4f835059bcc96030c061ae4c58d812c351658d75126be5013105787429ebbe56"
  },
  "18": {
    "text": "## CHECKLIST: Layout\r\n\r\n### 核对表: 布局\r\n\r\n#### 一般问题\r\n\r\n- [ ] 格式化主要是为了展现代码的逻辑结构吗?\r\n- [ ] 你的布局方案能统一地运用吗?\r\n- [ ] 你的布局方案能让代码易于维护吗?\r\n- [ ] 你的布局方案是否有利于代码的可读性?\r\n\r\n#### 控制结构的布局\r\n\r\n- [ ] 你的代码中避免 begin- end 对或{}的双重缩进了吗?\r\n- [ ] 相邻的块之间用空行分隔了吗?\r\n- [ ] 对复杂表达式格式化时考虑到可读性吗?\r\n- [ ] 对只有一条语句的块的布局始终如一吗?\r\n- [ ] case 语句与其他控制结构的格式化保持一致了吗?\r\n- [ ] 对 goto 语句的格式化是否让其显眼了呢?\r\n\r\n#### 单条语句的布局\r\n\r\n- [ ] 为逻辑表达式、数组下标和子程序参数的可读性而使用空格了吗?\r\n- [ ] 不完整的语句在行末是以明显有错的方式结束吗?\r\n- [ ] 后续行按照标准数目缩进了吗?\r\n- [ ] 每行顶多只有一条语句吗?\r\n- [ ] 所写的每个语句都没有副作用吗?\r\n- [ ] 每行顶多只声明一个数据吗?\r\n\r\n#### 注释的布局\r\n\r\n- [ ] 注释与其所注释的代码的缩进量相同吗?\r\n- [ ] 注释的风格便于维护吗?\r\n\r\n#### 子程序的布局\r\n\r\n- [ ] 你对每个子程序参数的格式化方式便于看懂、修改、注释吗?\r\n- [ ] 采用空行分隔子程序的各部分了吗?\r\n\r\n#### 类、文件和程序的布局\r\n\r\n- [ ] 多数类和文件之间是一一对应的关系吗?\r\n- [ ] 如果文件内有多个类,各类中的子程序按类分组了吗?各类都清楚标识了吗?\r\n- [ ] 文件中的子程序用空行清楚地分开了吗?\r\n- [ ] 在没有更好的组织形式的场合,所有子程序都按字母顺序排列了吗?\r\n\r\n### Key Points 要点\r\n\r\n- 可视化布局的首要任务是指明代码的逻辑组织。评估该任务是否实现的指标包括准确性、一致性、易读性和易维护性。\r\n- 外表悦目比起其他指标是最不重要的。然而, 如果其他指标都达到了, 代码又质量好, 那么布局效果看上去也会不错。\r\n- Visual Basic 具有纯代码块风格, 而 Java 的传统做法就是使用纯块风格, 所以若用这些语言编程, 就请使用纯代码块风格。C++ 中, 模拟纯代码块或者 begin-end 块边界都行之有效。\r\n- 结构化代码有其自身目的。始终如一地沿用某个习惯而少来创新。不能持久的布局规范只会损害可读性。\r\n- 布局的很多方面涉及信仰问题。应试着将客观需要和主观偏好区分开来。定出明确的指标, 在此基础上再讨论风格参数的选择。",
    "sourceFile": "CHECKLIST_Layout.md",
    "chunkHash": "572a1860be1587c3310b7a5066e3556d0823fd9bfbc9bdc031113a8d14d313fb"
  },
  "19": {
    "text": "## CHECKLIST: Loops\r\n\r\n### 核对表: 循环\r\n\r\n#### 循环的选择和创建\r\n\r\n- [ ] 在合适的情况下用 while 循环取代 for 循环了吗?\r\n- [ ] 循环是由内到外创建的吗?\r\n\r\n#### 进入循环\r\n\r\n- [ ] 是从循环头部进入的循环吗?\r\n- [ ] 初始化代码是直接位于循环前面吗?\r\n- [ ] 循环是无限循环或者事件循环吗?它的结构是否清晰?\r\n- [ ] 避免使用像 for  $\\mathbf{i} = 1$  to9999 这样的代码吗?\r\n- [ ] 如果这是一个  $\\mathbf{C} + +$  、C 或 Java 中的 for 循环,那么把循环头留给循环控制代码了吗?\r\n\r\n#### 循环的内部\r\n\r\n- [ ] 循环是否用了\" $\\{\\}$ \"或其等价物来括上循环体,以防止因修改不当而出错吗?\r\n- [ ] 循环体内有内容吗?它是非空的吗?\r\n- [ ] 把内务处理集中地放在循环开始或者循环结束处了吗?\r\n- [ ] 循环像定义良好的子程序那样只执行了一件操作吗?\r\n- [ ] 循环短得足以目了然吗?\r\n- [ ] 循环的嵌套层次不多于 3 层吗?\r\n- [ ] 把长循环的内容提取成单独的子程序吗?\r\n- [ ] 如果循环很长,那么它非常清晰吗?\r\n\r\n#### 循环下标\r\n\r\n- [ ] 如果这是一个 for 循环, 那么其中的代码有没有随意修改循环下标值?\r\n- [ ] 是否把重要的循环下标值保存在另外的变量里, 而不是在循环体外使用该循环下标?\r\n- [ ] 循环下标是序数类型 (整数) 或者枚举类型——而不是浮点类型——吗?\r\n- [ ] 循环下标的名字有意义吗?\r\n- [ ] 循环避免了下标串话问题吗?\r\n\r\n#### 退出循环\r\n\r\n- [ ] 循环在所有可能的条件下都能终止吗?\r\n- [ ] 如果你建立了某种安全计数器标准, 循环使用安全计数器了吗?\r\n- [ ] 循环的退出条件清晰吗?\r\n- [ ] 如果使用了 break 或者 continue, 那么它们用对了吗?\r\n\r\n### Key Points 要点\r\n\r\n- 循环很复杂。保持循环简单将有助于别人阅读你的代码。\r\n- 保持循环简单的技巧包括: 避免使用怪异的循环、减少嵌套层次、让入口和出口一目了然、把内务操作代码放在一处。\r\n- 循环下标很容易被滥用。因此命名要准确, 并且要把它们各自仅用于一个用途。\r\n- 仔细地考虑循环, 确认它在每一种情况下都运行正常, 并且在所有可能的条件下都能退出。",
    "sourceFile": "CHECKLIST_Loops.md",
    "chunkHash": "5ab77f29073103b82b0abb7f8da02a2c56dc58a5a5cf97092755bec4cb95943c"
  },
  "20": {
    "text": "## Checklist: Major Construction Practices\r\n\r\n### 核对表: 主要的构建实践\r\n\r\n#### 编码\r\n\r\n- [ ] 你有没有确定, 多少设计工作将要预先进行, 多少设计工作在键盘上进行(在编写代码的同时)?\r\n- [ ] 你有没有规定诸如名称、注释、代码格式等\"编码约定\"?\r\n- [ ] 你有没有规定特定的由软件架构确定的编码实践, 比如如何处理错误条件、如何处理安全性事项、对于类接口有哪些约定、可重用的代码遵循哪些标准、在编码时考虑多少性能因素等?\r\n- [ ] 你有没有找到自己在技术浪潮中的位置, 并相应调整自己的措施? 如果必要, 你是否知道如何\"深入一种语言去编程\", 而不受限于语言(仅仅\"在一种语言上编程\")?\r\n\r\n#### 团队工作\r\n\r\n- [ ] 你有没有定义一套集成工序——即, 你有没有定义一套特定的步骤, 规定程序员在把代码 check in(签入)到主源码(代码库)中之前, 必须履行这些步骤?\r\n- [ ] 程序员是结对编程、还是独自编程, 或者这二者的某种组合?\r\n- [ ] 交叉引用 关于质量保证的更多细节,请见第 20 章\"软件质量概述\"。\r\n\r\n#### 质量保证\r\n\r\n- [ ] 程序员在编写代码之前,是否先为之编写测试用例?\r\n- [ ] 程序员会为自己的代码写单元测试吗(无论先写还是后写)?\r\n- [ ] 程序员在 check in 代码之前,会用调试器单步跟踪整个代码流程吗?\r\n- [ ] 程序员在 check in 代码之前,是否进行集成测试(integration- test)?\r\n- [ ] 程序员会复审(review)或检查别人的代码吗?\r\n- [ ] 交叉引用 关于工具的更多细节,请见第 30 章\"编程工具\"。\r\n\r\n#### 工具\r\n\r\n- [ ] 你是否选用了某种版本控制工具?\r\n- [ ] 你是否选定了一种语言,以及语言的版本或编译器版本?\r\n- [ ] 你是否选择了某个编程框架(framework,如 J2EE 或 Microsoft.NET),或者明确地决定不使用编程框架?\r\n- [ ] 你是否决定允许使用非标准的语言特性?\r\n- [ ] 你是否选定并拥有了其他将要用到的工具——编辑器、重构工具、调试器、测试框架(test framework)、语法检查器等?\r\n\r\n### Key Points 要点\r\n\r\n- 每种编程语言都有其优点和弱点。要知道你使用的语言的明确优点和弱点。\r\n- 在开始编程之前,做好一些约定(convention)。\"改变代码使之符合这些约定\"是近乎不可能的。\r\n- \"构建的实践方法\"的种类比任何单个项目能用到的要多。有意识地选择最适合你的项目的实践方法。\r\n- 问问你自己,你采用的编程实践是对你所用的编程语言的正确响应,还是受\r\n- 它的控制?请记得\"深入一种语言去编程\",不要仅\"在一种语言上编程\"。\r\n- 你在技术浪潮中的位置决定了哪种方法是有效的——甚至是可能用到的。确定你在技术浪潮中的位置,并相应调整计划和预期目标。",
    "sourceFile": "Checklist_MajorConstructionPractices.md",
    "chunkHash": "3270fe8c571267d6ec9d5f4d0b06a2981db11fc481c71fea409cfded4621e85a"
  },
  "21": {
    "text": "## CHECKLIST: Naming Variables\r\n\r\n### 核对表: 变量命名\r\n\r\n#### 命名的一般注意事项\r\n\r\n- [ ] 名字完整并准确地表达了变量所代表的含义吗?\r\n- [ ] 名字反映了现实世界的问题而不是编程语言方案吗?\r\n- [ ] 名字足够长,可以让你无须苦苦思索吗?\r\n- [ ] 如果有计算值限定符,它被放在名字的最后吗?\r\n- [ ] 名字中用 Count 或者 Index 来代替 Num 了吗?\r\n\r\n#### 为特定类型的数据命名\r\n\r\n- [ ] 循环下标的名字有意义吗(如果循环的长度超出了一两行代码或者出现了嵌套循环,那么就应该是 i、j 或者 k 以外的其他名字)?\r\n- [ ] 所有的\"临时\"变量都重新命以更有意义的名字了吗?\r\n- [ ] 当布尔变量的值为真时,变量名能准确表达其含义吗?\r\n- [ ] 枚举类型的名字中含有能够表示其类别的前缀或后缀了吗?例如,把 color_用于 Color_Red, Color_Green, Color_Blue 等了吗?\r\n- [ ] 具名常量是根据它所代表的抽象实体而不是它所代表的数字来命名的吗?\r\n\r\n#### 命名规则\r\n\r\n- [ ] 规则能够区分局部数据、类的数据和全局数据吗?\r\n- [ ] 规则能够区分类型名、具名常量、枚举类型和变量名吗?\r\n- [ ] 规则能够在编译器不强制检测只读参数的语言里标识出子程序中的输入参数吗?\r\n- [ ] 规则尽可能地与语言的标准规则兼容吗?\r\n- [ ] 名字为了可读性而加以格式化吗?\r\n\r\n#### 短名字\r\n\r\n- [ ] 代码用了长名字吗(除非有必要使用短名字)?\r\n- [ ] 是否避免只为了省一个字符而缩写名字的情况?\r\n- [ ] 所有单词的缩写方式都一致吗?\r\n- [ ] 名字能够读出来吗?\r\n- [ ] 避免使用容易被看错或者读错的名字吗?\r\n- [ ] 在缩写对照表里对短名字做出说明吗?\r\n- [ ] 常见命名问题:你避免使用……\r\n\r\n  - [ ] ……容易让人误解的名字吗?\r\n  - [ ] ……有相近含义的名字吗?\r\n  - [ ] ……只有一两个字符不同的名字吗?\r\n  - [ ] ……发音相近的名字吗?\r\n  - [ ] ……包含数字的名字吗?\r\n  - [ ] ……为了缩短而故意拼错的名字吗?\r\n  - [ ] ……英语中经常拼错的名字吗?\r\n  - [ ] ……与标准库子程序名或者预定义变量名冲突的名字吗?\r\n  - [ ] ……过于随意的名字吗?\r\n  - [ ] ……含有难读的字符的名字吗?\r\n\r\n### Key Points 要点\r\n\r\n- 好的变量名是提高程序可读性的一项关键要素。对特殊种类的变量,比如循环下标和状态变量,需要加以特殊的考虑。\r\n- 名字要尽可能地具体。那些太模糊或者太通用以致于能够用于多种目的的名字通常都是很不好的。\r\n- 命名规则应该能够区分局部数据、类数据和全局数据。它们还应当可以区分类型名、具名常量、枚举类型名字和变量名。\r\n- 无论做哪种类型项目,你都应该采用某种变量命名规则。你所采用的规则的种类取决于你的程序的规模,以及项目成员的人数。\r\n- 现代编程语言很少需要用到缩写。如果你真的要使用缩写,请使用项目缩写词典或者标准前缀来帮助理解缩写。\r\n- 代码阅读的次数远远多于编写的次数。确保你所取的名字更侧重于阅读方便而不是编写方便。",
    "sourceFile": "CHECKLIST_NamingVariables.md",
    "chunkHash": "9c57431a9b726e5c23e8e84a8a5349a8107257f1108d8f7636de15de2bb78c17"
  },
  "22": {
    "text": "## Checklist: Organizing Straight-Line Code\r\n\r\n### 核对表：组织直线型代码\r\n\r\n- [ ] 代码使得语句之间的依赖关系变得明显吗？\r\n- [ ] 子程序的名字使得依赖关系变得明显吗？\r\n- [ ] 子程序的参数使得依赖关系变得明显吗？\r\n- [ ] 如果依赖关系不明确，你是否用注释进行了说明？\r\n- [ ] 你用“内务管理变量”（housekeeping variables）来检查代码中关键位置的顺序依赖关系了吗？\r\n- [ ] 代码容易按照自上而下的顺序阅读吗？\r\n- [ ] 相关的语句被组织在一起吗？\r\n- [ ] 把相对独立的语句组放进各自的子程序里吗？\r\n\r\n### Key Points 要点\r\n\r\n- 组织直线型代码的最主要原则是按照依赖关系进行排列。\r\n- 可以用好的子程序名、参数列表、注释，以及——如果代码足够重要——内务管理变量来让依赖关系变得更明显。\r\n- 如果代码之间没有顺序依赖关系，那就设法使相关的语句尽可能地接近。",
    "sourceFile": "Checklist_OrganizingStraight-LineCode.md",
    "chunkHash": "15a0efaabf68ce26521f22a0639c9af019464dd5bb486060854f6a81f3aadef0"
  },
  "23": {
    "text": "## CHECKLIST: Programming Tools\r\n\r\n### 核对表: 编程工具\r\n\r\n- [ ] 你有一套有效的 IDE 吗?\r\n- [ ] 你的 IDE 集成了:源代码控制、build/测试/除错工具,以及其他有用的功能吗?\r\n- [ ] 你有能自动进行常用的重构操作的工具吗?\r\n- [ ] 你是否使用版本控制工具,对源代码、内容、需求、设计、项目计划及其他的项目构件进行管理?\r\n- [ ] 如果你正面对超大型的项目,你是否使用了数据字典或者其他\"包含系统中使用的各个类的权威描述\"的中央知识库。\r\n- [ ] 当可以用到代码库时,你是否考虑用它来代替\"编写定制代码\"?\r\n- [ ] 你是否充分利用了交互式除错器?\r\n- [ ] 你是否使用 make 或其他\"依赖关系控制软件\",用来高效并可靠地 build 程序?\r\n- [ ] 你的测试环境包含有自动化的测试框架、自动测试生成器、覆盖率监视器、系统扰动器、diff 工具,以及缺陷跟踪软件吗?\r\n- [ ] 你有没有制造过定制工具——能满足特定项目的需求的那种,特别是能自动执行重复任务的工具?\r\n- [ ] 总而言之,你的工作环境有没有从\"充足的工具支援\"中获益?\r\n\r\n### Key Points 要点\r\n\r\n- 程序员有时会在长达数年的时间里忽视某些最强大的工具,之后才发现并使用之。\r\n- 好的工具能让你的日子过得安逸得多。\r\n- 下面这些工具已经可用了:编辑、分析代码质量、重构、版本控制、除错、测试、代码调整。\r\n- 你能打造许多自己用的专用工具。\r\n- 好的工具能减少软件开发中最单调乏味的工作的量,但它不能消除对\"编程\"的需要,虽然它会持续地重塑(reshape)\"编程\"的含义。",
    "sourceFile": "CHECKLIST_ProgrammingTools.md",
    "chunkHash": "d94dd1d7629365bf59780426c42eda622856a66bb0072351d9dfadb8b2b904b9"
  },
  "24": {
    "text": "## CHECKLIST: Reasons to Refactor\r\n\r\n### 核对表: 重构的理由\r\n\r\n- 代码重复。\r\n- 子程序太长。\r\n- 循环太长或者嵌套太深。\r\n- 类的内聚性太差。\r\n- 类的接口的抽象层次不一致。\r\n- 参数表中参数太多。\r\n- 类的内部修改往往局限于某个部分。\r\n- 需要对多个类进行并行修改。\r\n- 对继承体系的并行修改。\r\n- 需要对多个 case 语句进行并行修改。\r\n- 相关的数据项只是被放在一起,没有组织到类中。\r\n- 成员函数更多地使用了其他类的功能,而非自身类的。\r\n- 过于依赖基本数据类型。\r\n- 一个类不做什么事。\r\n- 连串传递流浪数据的子程序。\r\n- 中间人对象什么也不干。\r\n- 某个类同其他类关系过于密切。\r\n- 子程序的命名太差。\r\n- 数据成员被设置为公用。\r\n- 派生类仅仅使用了基类的一小部分成员函数。\r\n- 用注释来掩饰拙劣的代码。\r\n- 使用了全局变量。\r\n- 在子程序调用前使用设置代码,调用后使用收尾代码。\r\n- 程序包含的某些代码似乎在将来某个时候才会被用到。",
    "sourceFile": "CHECKLIST_ReasonstoRefactor.md",
    "chunkHash": "9c8a5631b7b74cdc89f20aef11c1fceb921a6ca630db7018cc1388d86bfccb22"
  },
  "25": {
    "text": "## CHECKLIST: Refactoring Safely\r\n\r\n### 核对表:安全的重构\r\n\r\n- [ ] 每一改变都是系统改变策略的一部分么?\r\n- [ ] 在重构之前,你保存了初始代码了么?\r\n- [ ] 你是否保持较小的重构步伐?\r\n- [ ] 你是否同一时间只处理一项重构?\r\n- [ ] 在重构时你是否把要做的事情一条条列了出来?\r\n- [ ] 你是否设置了一个停车场,把你在重构时所想到的任何东西记下来?\r\n- [ ] 在每次重构后你会重新测试么?\r\n- [ ] 如果所做的修改非常复杂,或者影响到了关键代码,你会重新检查这些修改么?\r\n- [ ] 你是否考虑过特定重构的风险,并以此来调整你的重构方法?\r\n- [ ] 你所做的修改是提升还是降低了程序的内在质量?\r\n- [ ] 你是否避免了将重构作为先写后改的代名词,或者作为拒绝重写拙劣代码的托词?\r\n\r\n### Key Points 要点\r\n\r\n- 修改是程序一生都要面对的事情,不仅包括最初的开发阶段,还包括首次发布之后。\r\n- 在修改中软件的质量要么改进,要么恶化。软件演化的首要法则就是代码演化应当提升程序的内在质量。\r\n- 重构成功之关键在于程序员应学会关注那些标志着代码需要重构的众多的警告或\"代码臭味\"。\r\n- 重构成功的另一要素是程序员应当掌握大量特定的重构方法。\r\n- 重构成功的最后要点在于要有安全重构的策略。一些重构方法会比其他重构方法要好。\r\n- 开发阶段的重构是提升程序质量的最佳时机,因为你可以立刻让刚刚产生的改变梦想变成现实。请珍惜这些开发阶段的天赐良机!",
    "sourceFile": "CHECKLIST_RefactoringSafely.md",
    "chunkHash": "92ef542bb95b9129c61af9ef242cd363ed5074f4cced8b84028a84fd5dc6e360"
  },
  "26": {
    "text": "## Checklist: Requirements\r\n\r\n### 核对表:需求\r\n\r\n这张需求核对表包含了一系列的问题——问问自己项目的需求工作做得如何。本书并不会告诉你如何做出好的需求分析,所以列表里面也不会有这样的问题。在开始构建之前,用这份列表做一次\"心智健全\"检查,看看你的地基到底有多坚固——用\"需求里氏震级\"来衡量。\r\n\r\n并不是核对表中所有的问题都适用于你的项目。如果你做的是一个非正式项目,那么你会发现有些东西根本就不需要考虑。你还会发现一些问题你需要考虑,但不需要做出正式的回答。如果你在做一个大型的、正式的项目,你也许就要逐条考虑了。\r\n\r\n#### 针对功能需求\r\n\r\n- [ ] 是否详细定义了系统的全部输入,包括其来源、精度、取值范围、出现频率等?\r\n- [ ] 是否详细定义了系统的全部输出,包括目的地、精度、取值范围、出现频率、格式等?\r\n- [ ] 是否详细定义了所有输出格式(Web 页面、报表,等等)?\r\n- [ ] 是否详细定义了所有硬件及软件的外部接口?\r\n- [ ] 是否详细定义了全部外部通信接口,包括握手协议、纠错协议、通信协议等?\r\n- [ ] 是否列出了用户想要做的全部事情?\r\n- [ ] 是否详细定义了每个任务所用的数据,以及每个任务得到的数据?\r\n\r\n#### 针对非功能需求(质量需求)\r\n\r\n- [ ] 是否为全部必要的操作,从用户的视角,详细描述了期望响应时间?\r\n- [ ] 是否详细描述了其他与计时有关的考虑,例如处理时间、数据传输率、系统吞吐量?\r\n- [ ] 是否详细定义了安全级别?\r\n- [ ] 是否详细定义了可靠性,包括软件失灵的后果、发生故障时需要保护的至关重要的信息、错误检测与恢复的策略等?\r\n- [ ] 是否详细定义了机器内存和剩余磁盘空间的最小值?\r\n- [ ] 是否详细定义了系统的可维护性,包括适应特定功能的变更、操作环境的变更、与其他软件的接口的变更能力?\r\n- [ ] 是否包含对\"成功\"的定义?\"失败\"的定义呢?\r\n\r\n#### 需求的质量\r\n\r\n- [ ] 需求是用用户的语言书写的吗?用户也这么认为吗?\r\n- [ ] 每条需求都不与其他需求冲突吗?\r\n- [ ] 是否详细定义了相互竞争的特性之间的权衡——例如,健壮性与正确性之间的权衡?\r\n- [ ] 是否避免在需求中规定设计(方案)?\r\n- [ ] 需求是否在详细程度上保持相当一致的水平?有些需求应该更详细地描述吗?有些需求应该更粗略地描述吗?\r\n- [ ] 需求是否足够清晰,即使转交给一个独立的小组去构建,他们也能理解吗?开发者也这么想吗?\r\n- [ ] 每个条款都与待解决的问题及其解决方案相关吗?能从每个条款上溯到它在问题域中对应的根源吗?\r\n- [ ] 是否每条需求都是可测试的?是否可能进行独立的测试,以检验满不满足各项需求?\r\n- [ ] 是否详细描述了所有可能的对需求的改动,包括各项改动的可能性?\r\n\r\n#### 需求的完备性\r\n\r\n- [ ] 对于在开始开发之前无法获得的信息,是否详细描述了信息不完全的区域?\r\n- [ ] 需求的完备度是否能达到这种程度:如果产品满足所有需求,那么它就是可接受的?\r\n- [ ] 你对全部需求都感到很舒服吗?你是否已经去掉了那些不可能实现的需求——那些只是为了安抚客户和老板的东西?",
    "sourceFile": "Checklist_Requirements.md",
    "chunkHash": "8f0a6a565abf7e744a588a405cf582e70d98a2fd6050b8e80350f492dab08101"
  },
  "27": {
    "text": "## CHECKLIST: Self-Documenting Code\r\n\r\n### 核对表: 自说明代码\r\n\r\n#### 类\r\n\r\n- [ ] 你的类接口体现出某种一致的抽象吗?\r\n- [ ] 你的类名有意义吗,能表明其中心意图吗?\r\n- [ ] 你的类接口对于如何使用该类显而易见吗?\r\n- [ ] 你的类接口能抽象到不需考虑其实现过程吗?能把类看成是黑盒吗?\r\n\r\n#### 子程序\r\n\r\n- [ ] 你的每个子程序名都能准确地指示该子程序确切干些什么吗?\r\n- [ ] 你的各子程序的任务明确吗?\r\n- [ ] 若各子程序中自成一体后更有用,你都将其各自独立出来了吗?\r\n- [ ] 每个子程序的接口都清晰明了吗?\r\n\r\n#### 数据名\r\n\r\n- [ ] 类型名描述有助于说明数据声明吗?\r\n- [ ] 你的变量名有意义吗?\r\n- [ ] 变量只用在其名字所代表意义的场合吗?\r\n- [ ] 你的循环变量名能给出更多信息,而不是 i、j、k 之类的吗?\r\n- [ ] 你用了名字有意义的枚举类型,而非临时拼凑的标识或者布尔变量吗?\r\n- [ ] 用具名常量代替神秘数值或者字符串了吗?\r\n- [ ] 你的命名规范能区分类型名、枚举类型、具名常量、局部变量、类变量以及全局变量吗?\r\n\r\n#### 数据组织\r\n\r\n- [ ] 你根据编程清晰的需要,使用了额外变量来提高清晰度吗?\r\n- [ ] 你对某变量的引用集中吗?\r\n- [ ] 数据类型简化到了最低复杂度吗?\r\n- [ ] 你是通过抽象访问子程序(抽象数据类型)来访问复杂数据吗?\r\n\r\n#### 控制\r\n\r\n- [ ] 代码中的正常执行路径很清晰吗?\r\n- [ ] 相关语句放在一起了吗?\r\n- [ ] 相对独立的语句组打包为子程序了吗?\r\n- [ ] 正常情况的处理位于 if 语句之后,而非在 else 子句中吗?\r\n- [ ] 控制结构简单明了,以使复杂度最低吗?\r\n- [ ] 每个循环完成且仅完成一个功能,是像定义良好的子程序那么做吗?\r\n- [ ] 嵌套层次是最少吗?\r\n- [ ] 逻辑表达式通过额外添加布尔变量、布尔函数和功能表简化了吗?\r\n\r\n#### 布局\r\n\r\n- [ ] 程序的布局能表现出其逻辑结构吗?\r\n\r\n#### 设计\r\n\r\n- [ ] 代码直截了当吗?是不是避免了自作聪明或新花样?\r\n- [ ] 实现细节尽可能隐藏了吗?\r\n- [ ] 程序是尽可能采用问题领域的术语,而非按照计算机科学或者编程语言的术语编写的吗?",
    "sourceFile": "CHECKLIST_Self-DocumentingCode.md",
    "chunkHash": "b5fdb46a0afaf9887779f0699944bd9c8196170cc26c4cc4213e47f91788da61"
  },
  "28": {
    "text": "## CHECKLIST: Summary of Refactorings\r\n\r\n### 核对表: 重构总结\r\n\r\n#### 数据级的重构\r\n\r\n- [ ] 用具名常量来代替神秘数值。\r\n- [ ] 用更明确或更具信息量的名字来重命名变量。\r\n- [ ] 将表达式内联化。\r\n- [ ] 用函数来代替表达式。\r\n- [ ] 引入中间变量。\r\n- [ ] 将多用途变量转换为多个单一用途变量。\r\n- [ ] 使用局部变量实现局部用途而不是使用参数。\r\n- [ ] 将基础数据类型转化为类。\r\n- [ ] 将一组类型码转化为类或是枚举类型。\r\n- [ ] 将一组类型码转化为含派生类的类。\r\n- [ ] 将数组转化为对象。\r\n- [ ] 封装群集。\r\n- [ ] 用数据类替代传统记录。\r\n\r\n#### 语句级的重构\r\n\r\n- [ ] 分解布尔表达式。\r\n- [ ] 将复杂的布尔表达式转换为命名精确的布尔函数。\r\n- [ ] 将条件语句中不同部分中的重复代码合并。\r\n- [ ] 使用 break 或 return 而不是循环控制变量。\r\n- [ ] 在嵌套的 if- then- else 语句中一旦知道结果就立刻退出,而不是仅仅赋个返回值。\r\n- [ ] 用多态来代替条件语句(尤其是重复的 case 语句)。\r\n- [ ] 创建并使用空对象代替对空值的检测。\r\n\r\n#### 子程序级的重构\r\n\r\n- [ ] 提取子程序。\r\n- [ ] 将子程序代码内联化。\r\n- [ ] 将长的子程序转化为类。\r\n- [ ] 用简单的算法替代复杂算法。\r\n- [ ] 增加参数。\r\n- [ ] 减少参数。\r\n- [ ] 将查询操作同修改操作区分开来。\r\n- [ ] 合并功能相似的子程序,并用参数来区分他们。\r\n- [ ] 通过传递不同的参数使子程序体现不同的功能。\r\n- [ ] 传递整个对象而非特定成员。\r\n- [ ] 传递特定成员而非整个对象。\r\n- [ ] 封装向下转型操作。\r\n\r\n#### 类实现的重构\r\n\r\n- [ ] 将值对象改为引用对象。\r\n- [ ] 将引用对象改为值对象。\r\n- [ ] 用数据初始化来代替虚函数。\r\n- [ ] 改变成员函数或数据的位置。\r\n- [ ] 将特定代码提出生成派生类。\r\n- [ ] 将相似的代码合并起来放到基类中。\r\n\r\n#### 类接口的重构\r\n\r\n- [ ] 将某成员子程序放到另一个类中。\r\n- [ ] 将一个类转化成两个。\r\n- [ ] 删除某个类。\r\n- [ ] 隐藏委托关系。\r\n- [ ] 去掉中间人。\r\n- [ ] 用委托代替继承。\r\n- [ ] 用继承代替委托。\r\n- [ ] 引入外部子程序。\r\n- [ ] 引入扩展类。\r\n- [ ] 封装暴露在外的成员变量。\r\n- [ ] 对不能修改的成员去掉 set()函数。\r\n- [ ] 隐藏在类的外部不会使用的成员函数。\r\n- [ ] 封装不会用到的成员函数。\r\n- [ ] 如果基类和派生类的代码实现相似,将二者合并。\r\n\r\n#### 系统级的重构\r\n\r\n- [ ] 为无法控制的数据创建明确的索引源。\r\n- [ ] 将单向类联系改为双向类联系。\r\n- [ ] 将双向的类联系改为单向类联系。\r\n- [ ] 使用工厂函数而非简单的构造函数。\r\n- [ ] 用异常代替错误代码,或者反其道而行之。",
    "sourceFile": "CHECKLIST_SummaryofRefactorings.md",
    "chunkHash": "a4a1faca18d2c0de369befe97be6b22599856187c172e1ff82be3d886e19e9da"
  },
  "29": {
    "text": "## CHECKLIST: Table-Driven Methods\r\n\r\n### 核对表: 表驱动法\r\n\r\n- [ ] 你考虑过把表驱动法作为复杂逻辑的替换方案吗?\r\n- [ ] 你考虑过把表驱动法作为复杂继承结构的替换方案吗?\r\n- [ ] 你考虑过把表数据存储在外部并在运行期间读入,以便在不修改代码的情况下就可以改变这些数据吗?\r\n- [ ] 如果无法用一种简单的数组索引(像 age 示例中那样)去访问表,那么你把计算访问键值的功能提取成单独的子程序,而不是在代码中重复地计算键值吗?\r\n\r\n### Key Points 要点\r\n\r\n- 表提供了一种复杂的逻辑和继承结构的替换方案。如果你发现自己对某个应用程序的逻辑或者继承树关系感到困惑,那么问问自己它是否可以通过一个查询表来加以简化。\r\n- 使用表的一项关键决策是决定如何去访问表。你可以采取直接访问、索引访问或者阶梯访问。\r\n- 使用表的另一项关键决策是决定应该把什么内容放入表中。",
    "sourceFile": "CHECKLIST_Table-DrivenMethods.md",
    "chunkHash": "7c2e51ffebb59369027ff5e6ce5f76429a9c2191c68ef7d3370cd5da95b6cc73"
  },
  "30": {
    "text": "## CHECKLIST: Test Cases\r\n\r\n### 核对表: 测试用例\r\n\r\n- [ ] 类和子程序所对应的每一项需求是否都有相应的测试用例?\r\n- [ ] 类和子程序所对应的每一个设计元素是否都有相应的测试用例?\r\n- [ ] 每行代码是否被至少一个测试用例所测试?你是否通过计算测试到每行代码所需的最少测试用例数量来验证这一点?\r\n- [ ] 所有已定义- 已使用路径是否至少被一个测试用例测试过了?\r\n- [ ] 是否测试过那些不太可能正确的数据流模式,例如已定义- 已定义、已定义- 已退出以及已定义- 已销毁?\r\n- [ ] 是否有一张常见错误列表,并据此编写测试用例以检测过去经常出现的错误?\r\n- [ ] 所有的简单边界是否都已经测试过了:最大、最小以及 off- by- one?\r\n- [ ] 是否测试了组合边界——即,多个输入数据的组合导致输出数据过小或者过大?\r\n- [ ] 测试用例是否检查了数据类型错误,例如一个薪水记账程序里的雇员数量是负数?\r\n- [ ] 是否测试了那些中规中矩的典型数值?\r\n- [ ] 是否测试了最小正常形式?\r\n- [ ] 是否测试了最大正常形式?\r\n- [ ] 是否检查了与旧数据的兼容性?以及是否对旧硬件、旧操作系统版本以及其他旧版本软件的接口进行了测试?\r\n- [ ] 测试用例是否容易手工检验?\r\n\r\n### Key Points 要点\r\n\r\n- 开发人员测试是完整测试策略的一个关键部分。独立测试也很重要, 但这一主题超出了本书的范围。\r\n- 同编码之后编写测试用例相比较, 编码开始之前编写测试用例, 工作量和花费的时间差不多, 但是后者可以缩短缺陷-侦测-调试-修正这一周期。\r\n- 即使考虑到了各种可用的测试手段, 测试仍然只是良好软件质量计划的一部分。高质量的开发方法至少和测试一样重要, 这包括尽可能减少需求和设计阶段的缺陷。在检测错误方面, 协同开发的成效至少与测试相当。这些方法所检测错误的类型也各不相同。\r\n- 你可以根据各种不同的思路来产生很多测试用例, 这些思路包括基础测试、数据流分析、边界分析、错误数据类型以及正确数据类型等。你还可以通过猜测错误的方式得到更多的测试用例。\r\n- 错误往往集中在少数几个容易出错的类和子程序上。找出这部分代码, 重新设计和编写它们。\r\n- 测试数据本身出错的密度往往比被测代码还要高。查找这种错误完全是浪费时间, 又不能对代码有所改善, 因此测试数据里面的错误更加让人烦恼。要像写代码一样小心地开发测试用例, 这样才能避免产生这种问题。\r\n- 自动化测试总体来说是很有用的, 也是进行回归测试的基础。\r\n- 从长远来看, 改善测试过程的最好办法就是将其规范化, 并对其进行评估, 然后用从评估中获得的经验教训来改善这个过程。",
    "sourceFile": "CHECKLIST_TestCases.md",
    "chunkHash": "01c042cbffa2b2a022b4748cb726e436610e0a9cc2ca739686999a0ae022c3ae"
  },
  "31": {
    "text": "## CHECKLIST: The Pseudocode Programming Process\r\n\r\n### 核对表: 伪代码编程过程\r\n\r\n- [ ] 是否检查过已满足所有的先决条件?\r\n- [ ] 定义好这个类要解决的问题了吗?\r\n- [ ] 高层次的设计是否足够清晰?能给这个类和其中的每一个子程序起一个好的名字吗?\r\n- [ ] 考虑过该如何测试这个类及其中每一个子程序了吗?\r\n- [ ] 关于效率的问题,你主要从稳定的接口和可读的实现这两个角度考虑吗?还是主要从满足资源和速度的预期目标的角度考虑过呢?\r\n- [ ] 在标准函数库或其他代码库中寻找过可用的子程序或者组件了吗?\r\n- [ ] 在参考书籍中查找过有用的算法了吗?\r\n- [ ] 是否用详尽的伪代码设计好每一个子程序?\r\n- [ ] 你在脑海里检查过伪代码吗?这些伪代码容易理解吗?\r\n- [ ] 关注过那些可能会让你重返设计的警告信息了吗?(比如说关于全局数据的使用、一些看上去更适合放在另一个类或子程序中的操作等。)\r\n- [ ] 是否把伪代码正确地翻译成代码了?\r\n- [ ] 你反复使用伪代码编程过程了吗?有没有根据需要把一些子程序拆分成更小的子程序?\r\n- [ ] 在做出假定(assumptions)的时候有没有对它们加以说明?\r\n- [ ] 已经删除掉那些冗余的注释了吗?\r\n- [ ] 你是否采取了几次迭代中最好的那个结果?还是在第一次迭代之后就停止了?\r\n- [ ] 你完全理解你的代码了吗?这些代码是否容易理解?\r\n\r\n### Key Points 要点\r\n\r\n- 创建类和子程序通常都是一个迭代的过程。在创建子程序的过程中获得的认识常常会反过来影响类的设计。\r\n- 编写好的伪代码需要使用易懂的英语,要避免使用特定编程语言中才有的特性,同时要在意图的层面上写伪代码(即描述该做什么,而不是要怎么去做)。\r\n- 伪代码编程过程是一个行之有效的做详细设计的工具,它同时让编码工作更容易。伪代码会直接转化为注释,从而确保了注释的准确度和实用性。\r\n- 不要只停留在你所想到的第一个设计方案上。反复使用伪代码做出多种方案,然后选出其中最佳的一种方案再开始编码。\r\n- 每一步完成后都要检查你的工作成果,还要鼓励其他人帮你来检查。这样你就会在投入精力最少的时候,用最低的成本发现错误。",
    "sourceFile": "CHECKLIST_ThePseudocodeProgrammingProcess.md",
    "chunkHash": "c0c87aa82e0547cbe3bc66c4dbca231417202740c64266f41b7d2a0cf8caede7"
  },
  "32": {
    "text": "## CHECKLIST: Unusual Control Structures\r\n\r\n### 核对表: 不常见的控制结构\r\n\r\n#### return\r\n\r\n- [ ] 每一个子程序都仅在有必要的时候才使用 return 吗?\r\n- [ ] 使用 return 有助于增强可读性吗?\r\n\r\n#### 递归\r\n\r\n- [ ] 递归子程序中包含了停止递归的代码吗?\r\n- [ ] 子程序用安全计数器来确保该子程序能停下来吗?\r\n- [ ] 递归只位于一个子程序里面吗?\r\n- [ ] 子程序的递归深度处于程序栈容量可以满足的限度内吗?\r\n- [ ] 递归是实现了程序的最佳方法吗? 它要好于简单的迭代吗?\r\n\r\n#### goto\r\n\r\n- [ ] 是否只有在万不得已的时候才使用 goto? 如果用了 goto, 是否仅仅是出于增强可读性和可维护性呢?\r\n- [ ] 如果是出于效率因素而使用的 goto, 那么对这种效率上的提升做出衡量并且加以说明了吗?\r\n- [ ] 一个子程序里最多只用了一个 goto 标号吗?\r\n- [ ] 所有的 goto 都向前跳转, 而不是向后跳转吗?\r\n- [ ] 所有的 goto 标号都用到了吗?\r\n\r\n### Key Points 要点\r\n\r\n- 多个 return 可以增强子程序的可读性和可维护性, 同时可以避免产生很深的嵌套逻辑。但是使用它的时候要多加小心。\r\n- 递归能够很优雅地解决一小部分问题。对它的使用也要倍加小心。\r\n- 在少数情况下, goto 是编写可读性和可维护代码的最佳方法。但这种情况非常罕见。除非万不得已, 不要使用 goto。",
    "sourceFile": "CHECKLIST_UnusualControlStructures.md",
    "chunkHash": "3e927d2efb2b31070d31be7ff9d9e405a6cde066a96de74373417cc575f0828f"
  },
  "33": {
    "text": "## Checklist: Upstream Prerequisites\r\n\r\n### 核对表: 前期准备\r\n\r\n- [ ] 你是否辨明了自己所从事的软件的类型,并对所用的开发方法做出相应的剪裁?\r\n- [ ] 是否充分明确地定义了需求?而且需求足够稳定,能开始构建了?(详见需求核对表。)\r\n- [ ] 是否充分明确地定义了架构,以便开始构建?(详见架构核对表。)\r\n- [ ] 是否已经指出你的(当前)项目中独有的风险(以避免构建活动面临不必要的风险)?\r\n\r\n### Key Points 要点\r\n\r\n- 构建活动的准备工作的根本目标在于降低风险。要确认你的准备活动是在降低风险,而非增加风险。\r\n- 如果你想开发高质量的软件,软件开发过程必须由始至终关注质量。在项目初期关注质量,对产品质量的正面影响比在项目末期关注质量的影响要大。\r\n- 程序员的一部分工作是教育老板和合作者,告诉他们软件开发过程,包括在开始编程之前进行充分准备的重要性。\r\n- 你所从事的软件项目的类型对构建活动的前期准备有重大影响——许多项目应该是高度迭代式的,某些应该是序列式的。\r\n- 如果没有明确的问题定义,那么你可能会在构建期间解决错误的问题。\r\n- 如果没有做完良好的需求分析工作,你可能没能察觉待解决的问题的重要细节。如果需求变更发生在构建之后的阶段,其代价是\"在项目早期更改需求\"的 20 至 100 倍。因此在开始编程之前,你要确认\"需求\"已经到位了。\r\n- 如果没有做完良好的架构设计,你可能会在构建期间用错误的方法解决正确的问题。架构变更的代价随着\"为错误的架构编写的代码数量\"增加而增加,因此,也要确认\"架构\"已经到位了。\r\n- 理解项目的前期准备所采用的方法,并相应地选择构建方法。",
    "sourceFile": "Checklist_UpstreamPrerequisites.md",
    "chunkHash": "3aced772718bb237c05385fad654921e584b033c91cf56306b546c9b95c681a5"
  },
  "34": {
    "text": "## CHECKLIST: Using Conditionals\r\n\r\n### 核对表: 使用条件语句\r\n\r\n#### if-then 语句\r\n\r\n- [ ] 代码的正常路径清晰吗?\r\n- [ ] if- then 测试对等量分支的处理方式正确吗?\r\n- [ ] 使用了 else 子句并加以说明吗?\r\n- [ ] else 子句用得对吗?\r\n- [ ] 用对了 if 和 else 子句, 即没把它们用反吗?\r\n- [ ] 需要执行的正常情况是位于 if 而不是 else 子句里吗?\r\n\r\n#### if-then-else-if 语句串\r\n\r\n- [ ] 把复杂的判断封装到布尔函数调用里了吗?\r\n- [ ] 先判断最常见的情况了吗?\r\n- [ ] 判断包含所有的情况吗?\r\n- [ ] if- then- else- if 是最佳的实现吗? 比 case 语句还要好吗?\r\n\r\n#### case 语句\r\n\r\n- [ ] case 子句排序得有意义吗?\r\n- [ ] 每种情况的操作简单吗? 必要的时候调用了其他子程序吗?\r\n- [ ] case 语句检测的是一个真实的变量, 而不是一个只为了滥用 case 语句而刻意制造变量吗?\r\n- [ ] 默认子句用得合法吗?\r\n- [ ] 用默认子句来检测和报告意料之外的情况了吗?\r\n- [ ] 在 C、C++ 或者 Java 里, 每一个 case 的末尾都有一个 break 吗?\r\n\r\n### Key Points 要点\r\n\r\n- 对于简单的 if-else 语句, 请注意 if 子句和 else 子句的顺序, 特别是用它来处理大量错误的时候。要确认正常的情况是清晰的。\r\n- 对于 if-then-else 语句串和 case 语句, 选择一种最有利于阅读的排序。\r\n- 为了捕捉错误, 可以使用 case 语句中的 default 子句 (默认子句), 或者使用 if-then-else 语句串中的最后那个 else 子句。\r\n- 各种控制结构并不是生来平等的。请为代码的每个部分选用最合适的控制结构。",
    "sourceFile": "CHECKLIST_UsingConditionals.md",
    "chunkHash": "278db0e5eb4ab614c75d2fc270dfb909b6b43c264a93ab9e7d3f12d7b9a73c9e"
  }
}